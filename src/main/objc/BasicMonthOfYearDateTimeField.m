//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/eric/repos/360-j2objc/joda-time/build/mainTranslationExtraction/org/joda/time/chrono/BasicMonthOfYearDateTimeField.java
//

#include "BasicChronology.h"
#include "BasicMonthOfYearDateTimeField.h"
#include "DateTimeConstants.h"
#include "DateTimeField.h"
#include "DateTimeFieldType.h"
#include "DateTimeUtils.h"
#include "DurationField.h"
#include "FieldUtils.h"
#include "IOSPrimitiveArray.h"
#include "ImpreciseDateTimeField.h"
#include "J2ObjC_source.h"
#include "ReadablePartial.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/Math.h"

@interface OrgJodaTimeChronoBasicMonthOfYearDateTimeField () {
 @public
  OrgJodaTimeChronoBasicChronology *iChronology_;
  jint iMax_;
  jint iLeapMonth_;
}

- (id)readResolve;

@end

J2OBJC_FIELD_SETTER(OrgJodaTimeChronoBasicMonthOfYearDateTimeField, iChronology_, OrgJodaTimeChronoBasicChronology *)

inline jlong OrgJodaTimeChronoBasicMonthOfYearDateTimeField_get_serialVersionUID();
#define OrgJodaTimeChronoBasicMonthOfYearDateTimeField_serialVersionUID -8258715387168736LL
J2OBJC_STATIC_FIELD_CONSTANT(OrgJodaTimeChronoBasicMonthOfYearDateTimeField, serialVersionUID, jlong)

inline jint OrgJodaTimeChronoBasicMonthOfYearDateTimeField_get_MIN();
#define OrgJodaTimeChronoBasicMonthOfYearDateTimeField_MIN 1
J2OBJC_STATIC_FIELD_CONSTANT(OrgJodaTimeChronoBasicMonthOfYearDateTimeField, MIN, jint)

@implementation OrgJodaTimeChronoBasicMonthOfYearDateTimeField

- (instancetype)initWithOrgJodaTimeChronoBasicChronology:(OrgJodaTimeChronoBasicChronology *)chronology
                                                 withInt:(jint)leapMonth {
  OrgJodaTimeChronoBasicMonthOfYearDateTimeField_initWithOrgJodaTimeChronoBasicChronology_withInt_(self, chronology, leapMonth);
  return self;
}

- (jboolean)isLenient {
  return false;
}

- (jint)getWithLong:(jlong)instant {
  return [((OrgJodaTimeChronoBasicChronology *) nil_chk(iChronology_)) getMonthOfYearWithLong:instant];
}

- (jlong)addWithLong:(jlong)instant
             withInt:(jint)months {
  if (months == 0) {
    return instant;
  }
  jlong timePart = [((OrgJodaTimeChronoBasicChronology *) nil_chk(iChronology_)) getMillisOfDayWithLong:instant];
  jint thisYear = [iChronology_ getYearWithLong:instant];
  jint thisMonth = [iChronology_ getMonthOfYearWithLong:instant withInt:thisYear];
  jint yearToUse = thisYear;
  ;
  jint monthToUse = thisMonth - 1 + months;
  if (thisMonth > 0 && monthToUse < 0) {
    yearToUse++;
    months -= iMax_;
    monthToUse = thisMonth - 1 + months;
  }
  if (monthToUse >= 0) {
    yearToUse = yearToUse + (monthToUse / iMax_);
    monthToUse = (monthToUse % iMax_) + 1;
  }
  else {
    yearToUse = yearToUse + (monthToUse / iMax_) - 1;
    monthToUse = JavaLangMath_absWithInt_(monthToUse);
    jint remMonthToUse = monthToUse % iMax_;
    if (remMonthToUse == 0) {
      remMonthToUse = iMax_;
    }
    monthToUse = iMax_ - remMonthToUse + 1;
    if (monthToUse == 1) {
      yearToUse += 1;
    }
  }
  jint dayToUse = [iChronology_ getDayOfMonthWithLong:instant withInt:thisYear withInt:thisMonth];
  jint maxDay = [iChronology_ getDaysInYearMonthWithInt:yearToUse withInt:monthToUse];
  if (dayToUse > maxDay) {
    dayToUse = maxDay;
  }
  jlong datePart = [iChronology_ getYearMonthDayMillisWithInt:yearToUse withInt:monthToUse withInt:dayToUse];
  return datePart + timePart;
}

- (jlong)addWithLong:(jlong)instant
            withLong:(jlong)months {
  jint i_months = (jint) months;
  if (i_months == months) {
    return [self addWithLong:instant withInt:i_months];
  }
  jlong timePart = [((OrgJodaTimeChronoBasicChronology *) nil_chk(iChronology_)) getMillisOfDayWithLong:instant];
  jint thisYear = [iChronology_ getYearWithLong:instant];
  jint thisMonth = [iChronology_ getMonthOfYearWithLong:instant withInt:thisYear];
  jlong yearToUse;
  jlong monthToUse = thisMonth - 1 + months;
  if (monthToUse >= 0) {
    yearToUse = thisYear + (monthToUse / iMax_);
    monthToUse = (monthToUse % iMax_) + 1;
  }
  else {
    yearToUse = thisYear + (monthToUse / iMax_) - 1;
    monthToUse = JavaLangMath_absWithLong_(monthToUse);
    jint remMonthToUse = (jint) (monthToUse % iMax_);
    if (remMonthToUse == 0) {
      remMonthToUse = iMax_;
    }
    monthToUse = iMax_ - remMonthToUse + 1;
    if (monthToUse == 1) {
      yearToUse += 1;
    }
  }
  if (yearToUse < [iChronology_ getMinYear] || yearToUse > [iChronology_ getMaxYear]) {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(JreStrcat("$J", @"Magnitude of add amount is too large: ", months));
  }
  jint i_yearToUse = (jint) yearToUse;
  jint i_monthToUse = (jint) monthToUse;
  jint dayToUse = [iChronology_ getDayOfMonthWithLong:instant withInt:thisYear withInt:thisMonth];
  jint maxDay = [iChronology_ getDaysInYearMonthWithInt:i_yearToUse withInt:i_monthToUse];
  if (dayToUse > maxDay) {
    dayToUse = maxDay;
  }
  jlong datePart = [iChronology_ getYearMonthDayMillisWithInt:i_yearToUse withInt:i_monthToUse withInt:dayToUse];
  return datePart + timePart;
}

- (IOSIntArray *)addWithOrgJodaTimeReadablePartial:(id<OrgJodaTimeReadablePartial>)partial
                                           withInt:(jint)fieldIndex
                                      withIntArray:(IOSIntArray *)values
                                           withInt:(jint)valueToAdd {
  if (valueToAdd == 0) {
    return values;
  }
  if ([((id<OrgJodaTimeReadablePartial>) nil_chk(partial)) size] > 0 && [((OrgJodaTimeDateTimeFieldType *) nil_chk([partial getFieldTypeWithInt:0])) isEqual:OrgJodaTimeDateTimeFieldType_monthOfYear()] && fieldIndex == 0) {
    jint curMonth0 = IOSIntArray_Get(nil_chk(values), 0) - 1;
    jint newMonth = ((curMonth0 + (valueToAdd % 12) + 12) % 12) + 1;
    return [self setWithOrgJodaTimeReadablePartial:partial withInt:0 withIntArray:values withInt:newMonth];
  }
  if (OrgJodaTimeDateTimeUtils_isContiguousWithOrgJodaTimeReadablePartial_(partial)) {
    jlong instant = 0LL;
    for (jint i = 0, isize = [partial size]; i < isize; i++) {
      instant = [((OrgJodaTimeDateTimeField *) nil_chk([((OrgJodaTimeDateTimeFieldType *) nil_chk([partial getFieldTypeWithInt:i])) getFieldWithOrgJodaTimeChronology:iChronology_])) setWithLong:instant withInt:IOSIntArray_Get(nil_chk(values), i)];
    }
    instant = [self addWithLong:instant withInt:valueToAdd];
    return [((OrgJodaTimeChronoBasicChronology *) nil_chk(iChronology_)) getWithOrgJodaTimeReadablePartial:partial withLong:instant];
  }
  else {
    return [super addWithOrgJodaTimeReadablePartial:partial withInt:fieldIndex withIntArray:values withInt:valueToAdd];
  }
}

- (jlong)addWrapFieldWithLong:(jlong)instant
                      withInt:(jint)months {
  return [self setWithLong:instant withInt:OrgJodaTimeFieldFieldUtils_getWrappedValueWithInt_withInt_withInt_withInt_([self getWithLong:instant], months, OrgJodaTimeChronoBasicMonthOfYearDateTimeField_MIN, iMax_)];
}

- (jlong)getDifferenceAsLongWithLong:(jlong)minuendInstant
                            withLong:(jlong)subtrahendInstant {
  if (minuendInstant < subtrahendInstant) {
    return -[self getDifferenceWithLong:subtrahendInstant withLong:minuendInstant];
  }
  jint minuendYear = [((OrgJodaTimeChronoBasicChronology *) nil_chk(iChronology_)) getYearWithLong:minuendInstant];
  jint minuendMonth = [iChronology_ getMonthOfYearWithLong:minuendInstant withInt:minuendYear];
  jint subtrahendYear = [iChronology_ getYearWithLong:subtrahendInstant];
  jint subtrahendMonth = [iChronology_ getMonthOfYearWithLong:subtrahendInstant withInt:subtrahendYear];
  jlong difference = (minuendYear - subtrahendYear) * ((jlong) iMax_) + minuendMonth - subtrahendMonth;
  jint minuendDom = [iChronology_ getDayOfMonthWithLong:minuendInstant withInt:minuendYear withInt:minuendMonth];
  if (minuendDom == [iChronology_ getDaysInYearMonthWithInt:minuendYear withInt:minuendMonth]) {
    jint subtrahendDom = [iChronology_ getDayOfMonthWithLong:subtrahendInstant withInt:subtrahendYear withInt:subtrahendMonth];
    if (subtrahendDom > minuendDom) {
      subtrahendInstant = [((OrgJodaTimeDateTimeField *) nil_chk([iChronology_ dayOfMonth])) setWithLong:subtrahendInstant withInt:minuendDom];
    }
  }
  jlong minuendRem = minuendInstant - [iChronology_ getYearMonthMillisWithInt:minuendYear withInt:minuendMonth];
  jlong subtrahendRem = subtrahendInstant - [iChronology_ getYearMonthMillisWithInt:subtrahendYear withInt:subtrahendMonth];
  if (minuendRem < subtrahendRem) {
    difference--;
  }
  return difference;
}

- (jlong)setWithLong:(jlong)instant
             withInt:(jint)month {
  OrgJodaTimeFieldFieldUtils_verifyValueBoundsWithOrgJodaTimeDateTimeField_withInt_withInt_withInt_(self, month, OrgJodaTimeChronoBasicMonthOfYearDateTimeField_MIN, iMax_);
  jint thisYear = [((OrgJodaTimeChronoBasicChronology *) nil_chk(iChronology_)) getYearWithLong:instant];
  jint thisDom = [iChronology_ getDayOfMonthWithLong:instant withInt:thisYear];
  jint maxDom = [iChronology_ getDaysInYearMonthWithInt:thisYear withInt:month];
  if (thisDom > maxDom) {
    thisDom = maxDom;
  }
  return [iChronology_ getYearMonthDayMillisWithInt:thisYear withInt:month withInt:thisDom] + [iChronology_ getMillisOfDayWithLong:instant];
}

- (OrgJodaTimeDurationField *)getRangeDurationField {
  return [((OrgJodaTimeChronoBasicChronology *) nil_chk(iChronology_)) years];
}

- (jboolean)isLeapWithLong:(jlong)instant {
  jint thisYear = [((OrgJodaTimeChronoBasicChronology *) nil_chk(iChronology_)) getYearWithLong:instant];
  if ([iChronology_ isLeapYearWithInt:thisYear]) {
    return [iChronology_ getMonthOfYearWithLong:instant withInt:thisYear] == iLeapMonth_;
  }
  return false;
}

- (jint)getLeapAmountWithLong:(jlong)instant {
  return [self isLeapWithLong:instant] ? 1 : 0;
}

- (OrgJodaTimeDurationField *)getLeapDurationField {
  return [((OrgJodaTimeChronoBasicChronology *) nil_chk(iChronology_)) days];
}

- (jint)getMinimumValue {
  return OrgJodaTimeChronoBasicMonthOfYearDateTimeField_MIN;
}

- (jint)getMaximumValue {
  return iMax_;
}

- (jlong)roundFloorWithLong:(jlong)instant {
  jint year = [((OrgJodaTimeChronoBasicChronology *) nil_chk(iChronology_)) getYearWithLong:instant];
  jint month = [iChronology_ getMonthOfYearWithLong:instant withInt:year];
  return [iChronology_ getYearMonthMillisWithInt:year withInt:month];
}

- (jlong)remainderWithLong:(jlong)instant {
  return instant - [self roundFloorWithLong:instant];
}

- (id)readResolve {
  return [((OrgJodaTimeChronoBasicChronology *) nil_chk(iChronology_)) monthOfYear];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, 0, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 1, 2, -1, -1, -1, -1 },
    { NULL, "J", 0x1, 3, 4, -1, -1, -1, -1 },
    { NULL, "J", 0x1, 3, 5, -1, -1, -1, -1 },
    { NULL, "[I", 0x1, 3, 6, -1, -1, -1, -1 },
    { NULL, "J", 0x1, 7, 4, -1, -1, -1, -1 },
    { NULL, "J", 0x1, 8, 5, -1, -1, -1, -1 },
    { NULL, "J", 0x1, 9, 4, -1, -1, -1, -1 },
    { NULL, "LOrgJodaTimeDurationField;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 10, 2, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 11, 2, -1, -1, -1, -1 },
    { NULL, "LOrgJodaTimeDurationField;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "I", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "I", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "J", 0x1, 12, 2, -1, -1, -1, -1 },
    { NULL, "J", 0x1, 13, 2, -1, -1, -1, -1 },
    { NULL, "LNSObject;", 0x2, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(initWithOrgJodaTimeChronoBasicChronology:withInt:);
  methods[1].selector = @selector(isLenient);
  methods[2].selector = @selector(getWithLong:);
  methods[3].selector = @selector(addWithLong:withInt:);
  methods[4].selector = @selector(addWithLong:withLong:);
  methods[5].selector = @selector(addWithOrgJodaTimeReadablePartial:withInt:withIntArray:withInt:);
  methods[6].selector = @selector(addWrapFieldWithLong:withInt:);
  methods[7].selector = @selector(getDifferenceAsLongWithLong:withLong:);
  methods[8].selector = @selector(setWithLong:withInt:);
  methods[9].selector = @selector(getRangeDurationField);
  methods[10].selector = @selector(isLeapWithLong:);
  methods[11].selector = @selector(getLeapAmountWithLong:);
  methods[12].selector = @selector(getLeapDurationField);
  methods[13].selector = @selector(getMinimumValue);
  methods[14].selector = @selector(getMaximumValue);
  methods[15].selector = @selector(roundFloorWithLong:);
  methods[16].selector = @selector(remainderWithLong:);
  methods[17].selector = @selector(readResolve);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "serialVersionUID", "J", .constantValue.asLong = OrgJodaTimeChronoBasicMonthOfYearDateTimeField_serialVersionUID, 0x1a, -1, -1, -1, -1 },
    { "MIN", "I", .constantValue.asInt = OrgJodaTimeChronoBasicMonthOfYearDateTimeField_MIN, 0x1a, -1, -1, -1, -1 },
    { "iChronology_", "LOrgJodaTimeChronoBasicChronology;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "iMax_", "I", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "iLeapMonth_", "I", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LOrgJodaTimeChronoBasicChronology;I", "get", "J", "add", "JI", "JJ", "LOrgJodaTimeReadablePartial;I[II", "addWrapField", "getDifferenceAsLong", "set", "isLeap", "getLeapAmount", "roundFloor", "remainder" };
  static const J2ObjcClassInfo _OrgJodaTimeChronoBasicMonthOfYearDateTimeField = { "BasicMonthOfYearDateTimeField", "org.joda.time.chrono", ptrTable, methods, fields, 7, 0x0, 18, 5, -1, -1, -1, -1, -1 };
  return &_OrgJodaTimeChronoBasicMonthOfYearDateTimeField;
}

@end

void OrgJodaTimeChronoBasicMonthOfYearDateTimeField_initWithOrgJodaTimeChronoBasicChronology_withInt_(OrgJodaTimeChronoBasicMonthOfYearDateTimeField *self, OrgJodaTimeChronoBasicChronology *chronology, jint leapMonth) {
  OrgJodaTimeFieldImpreciseDateTimeField_initWithOrgJodaTimeDateTimeFieldType_withLong_(self, OrgJodaTimeDateTimeFieldType_monthOfYear(), [((OrgJodaTimeChronoBasicChronology *) nil_chk(chronology)) getAverageMillisPerMonth]);
  self->iChronology_ = chronology;
  self->iMax_ = [self->iChronology_ getMaxMonth];
  self->iLeapMonth_ = leapMonth;
}

OrgJodaTimeChronoBasicMonthOfYearDateTimeField *new_OrgJodaTimeChronoBasicMonthOfYearDateTimeField_initWithOrgJodaTimeChronoBasicChronology_withInt_(OrgJodaTimeChronoBasicChronology *chronology, jint leapMonth) {
  J2OBJC_NEW_IMPL(OrgJodaTimeChronoBasicMonthOfYearDateTimeField, initWithOrgJodaTimeChronoBasicChronology_withInt_, chronology, leapMonth)
}

OrgJodaTimeChronoBasicMonthOfYearDateTimeField *create_OrgJodaTimeChronoBasicMonthOfYearDateTimeField_initWithOrgJodaTimeChronoBasicChronology_withInt_(OrgJodaTimeChronoBasicChronology *chronology, jint leapMonth) {
  J2OBJC_CREATE_IMPL(OrgJodaTimeChronoBasicMonthOfYearDateTimeField, initWithOrgJodaTimeChronoBasicChronology_withInt_, chronology, leapMonth)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(OrgJodaTimeChronoBasicMonthOfYearDateTimeField)
